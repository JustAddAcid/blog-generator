---
title: 'Как запилить реактивность на SAPUI5 -- часть 1'
excerpt: 'Решил описать то, как можно удобно хранить состояния экранов (или всего приложения) внутри SAPUI5 и заниматься реактивностью (Почти как у больших и нормальных фреймворков)'
coverImage: '/assets/blog/sapui5-state/cover2.jpg'
date: '2020-06-15T14:15:07.322Z'
issueId: '10'
author:
  name: Roman A. Nosov
  picture: '/assets/blog/authors/romannosov.png'
ogImage:
  url: '/assets/blog/sapui5-state/cover2.jpg'
---

Решил описать то, как можно удобно хранить состояния экранов (или всего приложения) внутри *SAPUI5* и делать реактивность (Почти как у больших и нормальных фреймворков).

**Для тех, кто в танке и никогда не слышал, что это такое** *SAPUI5* -- это фронтенд-фреймворк. Как  хипстерские *Vue* и *React*, только никому не нужен. Используется для быстрого написания фронтендов поверх выгрузки данных из SAP-ERP. 

Внезапно, но он действительно неплохо интегрирован со всей сап-экосистемой и простенькие приложения (внутри определенных рамок) писать не сильно больно. Проблемы начинаются тогда, когда нужно сделать что-то *большее*, чем просто нарисовать табличку с двумя кнопками. И внезапно вылезают всеобщая громоздкость синтаксиса, нестабильность работы некоторых контролов и отсутствие нормального комьюнити.

![Learning programming sapui5](/assets/blog/sapui5-state/meme.png)

## Стейты стейты стейты

### Для начала немного теории

Что такое реактивное программирование очень хорошо объяснено [(здесь)](https://webdevblog.ru/ponimanie-reaktivnosti-vo-vue-js-shag-za-shagom/) только примеры для другого фреймворка. Но это не важно! :)

В основе лежит идея о том, что было бы очень неплохо, если бы контролы сами смотрели в данные и **перестраивались** бы автоматически, если что-нибудь в этих данных поменяется, без кучи явных хендлеров и присвоений значений в контролы по многу раз. 

И наоборот -- было бы неплохо, если бы данные **перестраивались** автоматически, если, например, в каком-нибудь input'e пользователь ввел другое значение.

#### Вот такой вот интересный **two-way binding** ¯\\_(ツ)_/¯

Давайте человеческим языком -- суть в том, что все данные у нас сложены в одну коробку (массив/объект) и все контролы на странице рендерятся на основе этих данных. 

Плюсы здесь в том, что это, мать его, облегчает чтение и уменьшает размер нашего нелюбимого жабаскрипта. А чем меньше жабаскрипта -- тем лучше.

А ещё сразу понятно, что приложение делает, если взглянуть на модель данных. А ещё это кодится быстрее за ту же зарплату. Ну вы понимаете.

### Разберем на практике избитый пример:

#### Тудушница

Давайте за минуту напишем простейший toDo-лист с единым хранением состояния. 

Для начала создаём пустое *SAPUI5* приложение с единственной view -- *index.view.xml*, которая сразу при открытии будет отображаться пользователю. 

Идем от данных! Какие данные примерно должна хранить todo-list? Наверное, массив заметок с полями: checked, text, и id. Ну и содержимое текстового поля, которое генерирует новые заметки. Получилось примерно вот так:

```javascript
{
    input: "",
    todos: [
    // Тут будут объекты вот в таком формате:
    // 	{
    // 	id: "1",
    // 	text: "one",
    // 	checked: true
    // }
    ]
  }
```

Состояние в *SAPUI5* лучше всего хранить в объекте класса sap.ui.model.json.**JSONModel**. Он позволяет подписываться на изменения каждого из свойства хранимого объекта, - как из XML-view в декларативном стиле, так и напрямую писать хендлеры изменений из кода. Почему класс называется именно JSONModel - для меня остаётся загадкой, т.к. де-факто он хранит обычный JavaScript объект.

Открываем файл */controller/index.controller.js* и по событию инициализации создаём *JSON-model* и заполняем её данными.

```javascript
  onInit: function() {
    this.viewState = new JSONModel({
      input: "",
      todos: []
    });

    this.getView().setModel(this.viewState, "viewState");
  }
```

Модель присваивается к *View* с помощью метода *.setModel*. В данном конкретном случае псевдоним модели ("*viewState*") можно было не указывать, т.к. модель всего одна и путаницы возникнуть не может. 

Давайте попробуем представить, как бы у нас выглядел метод создания новой заметки:

```javascript
  appendTodo: function(){
    var todos = this.viewState.getProperty("/todos");
    
    this.viewState.setProperty("/todos", todos.concat([{
      id: new Date().getTime().toString(),
      text: this.viewState.getProperty("/input"),
      checked: false
    }]));
    
    this.viewState.setProperty("/input", "");
  },
```

Очень просто. Получение массива заметок, создание массива со старыми + новой заметкой и присвоение его к модели. Затем очистка поля ввода.

В качестве id нам пока вполне подойдет текущий таймстемп. Вместо Array.prototype.concat, если очень хочется, можно использовать ES6 spread operator:

```javascript
  const newArray = [...oldArray, newElement]
```

Но не очень нужно, т.к. у sapui5 из коробки нет никакого препроцессинга кода, а написанный энтузиастами плагин для Babel не для production-use. И используя фичи es6 мы автоматически делаем наш код неспособным запуститься на ie10-11 (а у некоторых он до сих пор -- корпоративный стандарт).

Переходим к разметке интерфейса. Там всё просто: поле создания заметок + список.

```xml
  <content>
    <Input value="{viewState>/input}" submit="appendTodo"/>
    <List items="{viewState>/todos}">
      <items>
        <CustomListItem>
          <HBox>
            <CheckBox selected="{viewState>checked}"/>
            <Input width="500px" value="{viewState>text}"/>
            <Button text="X" press="deleteTodo" data:id="{viewState>id}"/>
          </HBox>
        </CustomListItem>
      </items>
    </List>
  </content>
```

ID заметки будем передавать в data-* атрибуте. (Чтобы неймспейс data: в разметке заработал, нужно его подключить в самом верху view)

```xml
<mvc:View 
  controllerName="todoTodo.controller.index" 
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns:mvc="sap.ui.core.mvc"
	displayBlock="true" 
  xmlns="sap.m" 
  xmlns:data="http://schemas.sap.com/sapui5/extension/sap.ui.core.CustomData/1">
```

Метод удаления заметки: Получаем id из data-* атрибута и фильтруем массив.

```javascript
  deleteTodo: function(event){
    var id = event.getSource().data("id");
    var todos = this.viewState.getProperty("/todos");
    this.viewState.setProperty("/todos", todos.filter(function(todo){
      return todo.id !== id;
    }));
  }
```

Запускаем -- работает! Написано всего два простых метода. 

Сейчас нам **ничего** не стоит забрать данные и записать в *localStorage* браузера, или отправить на *сервер*, или как-то обрабатывать в коде, т.к. мы всегда знаем, где находятся данные и как они организованы.

А теперь давайте представим, сколько бы нам потребовалось геморроя, если бы мы писали это в классическом html+js... Приходилось бы руками описывать хендлеры событий каждого контрола, а сборка данных для отправки на сервер превратилась бы в сущий ад в виде цикла по всем контролам и вытаскивания значения. Конечно, для данного примера этот аргумент звучит не слишком сурово. Но представьте здоровенное *SPA* приложение с несколькими сотнями контролов в сложной иерархии...

А пока - простейшее туду:

![Запускаем -- работает](/assets/blog/sapui5-state/basic-todo.png)

В представленном варианте: в модели *viewState* будет храниться объект со следующим содержанием:

```javascript
{
    input: ""
    todos: {
        { id: "1592739272730", text: "Раз", checked: false }
        { id: "1592739273593", text: "Два", checked: true }
        { id: "1592739274600", text: "Три", checked: false }
        { id: "1592739276362", text: "Четыре", checked: true }
        { id: "1592739277545", text: "Пять", checked: false }
    }
}
```

[((Репо с кодом))](https://github.com/JustAddAcid/sapui5-todo)

Продолжение следует.