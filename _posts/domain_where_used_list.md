---
title: 'Ищем в каких таблицах используется домен в ABAP'
titleEnabled: false
excerpt: 'Пишем удобную утилиту, которая позволит найти, в каких таблицах БД используется выбранный домен и вычислить количество в них строк'
coverImage: '/assets/blog/domain_where_used_list/background.jpg'
date: '2020-07-12T14:15:07.322Z'
issueId: '13'
author:
  name: Roman A. Nosov
  picture: '/assets/blog/authors/romannosov.png'
ogImage:
  url: '/assets/blog/domain_where_used_list/background.jpg'
---

Какое здесь может быть введение? Продолжаю писать образовательные посты с небольшими вкраплениями абсурда, мемов и ненависти ко всему окружающему. Сегодня пишем утилиту. Под *SAP*. Своё отношение к разработке на этой платформе высказывал в [предыдущей статье](/posts/zcl-date-abap).

Конкретно эта программа -- очень хороший пример, как сама система вынуждает разработчиков усложнять код и делать костыли, чтобы обойти абсолютно **искусственно** расставленные ограничения. Усаживайтесь поудобнее, мы начинаем!

![Девайсы для abap'еров](/assets/blog/domain_where_used_list/device.jpg)

## Немного теории

**Що таке домени в *SAP*?**

**Домены в SAP** -- это то, что ~~нормальные~~ люди называют *типами данных*. То, как данные представлены непосредственно в памяти программы, или *СУБД*: строка из N символов, int32, int64, float, enum из определенного набора значений и т.д.

Есть ещё такое понятие в *SAP* - тусовке, как **элемент данных** (*data element*). Это "тип данных на максималках" -- который содержит в себе **не только** описание того, как эти данные лежат в памяти, но и дополнительные плюшки в виде:

1. Дефолтный заголовок этого поля для разных языков (который подтягивается в поле ввода, или заголовок таблицы по умолчанию)
2. Ссылка на "средство поиска" -- программу, которая помогает пользователю заполнить input значением. (Например, предоставить выбор из списка контрагентов, с заданными параметрами)
3. ... прочие второстепенные штуки

Т.е. сначала объявляется домен, от него наследуется элемент данных, который уже используется для объявления переменных/объявления столбцов в таблицах БД.

![Схема наследования](/assets/blog/domain_where_used_list/data_element.jpg)

Оукей, на первых парах нам этой информации достаточно. Остальное будем понимать по ходу процесса:

## Процесс 

**Формулируем**, что мы хотим получить в итоге. Программу, которая:

1. Принимает на вход **имя домена** и параметр:
   1. Считать ли количество строк в таблицах
2. Выводит список таблиц со следующими полями:
   1. Имя таблицы, которая использует введенный домен
   2. Название поля таблицы
   3. Имя элемента данных этого поля
   4. Количество строк **или** результат проверки на пустоту (в зависимости от входного параметра) 

На самом деле, 95% этой задачи решаются очень быстро. Достаточно найти место в базе данных, где хранятся соответствия таблицы -> типа данных -> домена и сделать селект. (Благо, в SAP хранится в БД **ВСЁ**, включая программный код)

Методом скоростного гугления обнаруживаем две таблицы, которые нам в этом могут помочь:

1. **dd03l** -- соответствие: таблица - поле - тип данных - домен
2. **dd02l** -- соответствие: таблица - класс таблицы (нас не интересуют объявленные типы таблиц, которые **не** используются в БД)

Ну и простейший селект из них:

```abap
SELECT DISTINCT dd03l~domname dd03l~rollname dd03l~fieldname
    dd03l~tabname
  INTO CORRESPONDING FIELDS OF TABLE rt_tables
  FROM dd03l JOIN dd02l
    ON dd03l~tabname = dd02l~tabname AND
      dd03l~as4local = dd02l~as4local
  WHERE
    dd03l~domname IN ir_domains AND
    " Активные
    dd03l~as4local = 'A' AND
    " Таблицы, которые используются в СУБД
    dd02l~tabclass IN ('TRANSP', 'CLUSTER', 'POOL').
```

Проверка количества записей делается самым очевидным способом: **select count(\*)** в цикле по всем таблицам.

```abap
LOOP AT lt_tables ASSIGNING <ls_table>.
  SELECT SINGLE COUNT(*)
    FROM (<ls_unique_table>-tabname)
    INTO lv_records_count.

  " [ .... ]
ENDLOOP.
```

Казалось бы, что может пойти не так? Всего-лишь осталось реализовать проверку таблицы на пустоту, не делая select count(\*) по всей таблице. 

Поскольку за выполнение запросов напрямую в **БД**, минуя прослойку **ABAP** -- абаперов бьют по рукам (особенно при миграции на другую *СУБД*). Разработчиком приходится довольствоваться куцым подмножеством **sql**, который предоставляет ABAP API. В нём напрочь отсутствует не только *database-specific-features*, но и вполне стандартные вещи типа вложенных запросов.

Т.е. вот такой простой и понятный запрос у нас ни за что не выполнится:
```sql
select count(*) 
from (select top 1 * 
      from TABLE)
```

Приходится изобретать велосипед. И единственным выходом в этой ситуации будет попытка сделать селект **хотя-бы одной** записи из таблицы и проверка на успех.

Сказано-сделано:
```abap
LOOP AT lt_tables ASSIGNING <ls_table>.
  SELECT SINGLE *
    FROM (<ls_unique_table>-tabname)
    INTO " ...
  " Так, стоп. А куда присваивать значение?
  " [ .... ]
ENDLOOP.
```

Блок **into %var%** пропустить нельзя. Без него компиллятор сваливается с ошибкой. (Про ABAP-подобие байткода как-нибудь в другой раз)

А куда присваивать значения, если заранее неизвестен тип данных? В **ABAP** таких "безразмерных" типов нет. Так что, придется как-то объявлять переменные в рантайме. Но с этим не всё так гладко! :)

## Длинное отступление про принцип объявления переменных в ABAP

Казалось бы, о чем здесь рассказывать? Почти каждый относительно-высокоуровневый язык предоставляет очень простой *API* для объявления переменных. 

В данном случае, переменные объявляются ключевым словом **DATA**, далее идет указание имени переменной и её тип:
```abap
data some_name type string.
```

Но, поскольку, *abap* -- достаточно старый язык, он тянет за собой весьма странное легаси-поведение, которое в современном мире кажется моветоном. Например:
```abap
if 1 = 1.
    data some_string type string.
    some_string = 'hello world'.
endif.

write some_string.
```
Уважаемые знатоки, внимание вопрос: выполнится ли этот код без ошибки? И выведется ли *hello world?*<br>
Правильные ответы: **да и да**.

Если вы на секунду подумали, что объявление переменных в *abap* ведет себя так же, как ключевое слово **var** в *JavaScript*, и переменная *"вываливается"* за текущий блок, то спешу вас разочаровать... 
```abap
if 1 = 2.
    " Никогда не выполнится
    data some_string type string.
endif.

some_string = 'hello world'.
write some_string. "hello world 
"(да, это работает)
```

Несмотря на то, что выполнение основного интерпретатора программы **никогда** не зайдёт в блок **IF**, переменная всё равно объявится!

**N.B.**: перед выполнением кода, его быстренько пробегает интерпретатор и выделяет память под **все** используемые переменные в этой подпрограмме/методе.

А объявленные переменные будут доступны в **любом месте** внутри метода/подпрограммы.

На самом деле, это больше похоже на хостинг функций в *JavaScript*. [Который хорошо описан здесь.](https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5)

Значит ли это, ~~что всё предопределено~~ что мы не можем выделять память в рантайме, когда на момент компилляции неизвестен тип? 

И да и нет. Саму переменную всё-таки придется объявить в виде ссылки на "какую-то" область памяти. А уточнить тип, и выделить под неё память мы можем тогда, когда нам это потребуется. Выглядит это следующим образом:
```abap
" Создаём переменную, как ссылку на "какие-то" данные
data my_var type ref to data.
" Выделяем память под нужный тип данных
create data my_var type ('typename').
```

Это, конечно, прекрасно. Но так просто обращаться к этой области памяти и записывать/читать данные у нас не получится! :) Для этого нам потребуется познакомиться с ещё одним abap-концептом.

Это **field-symbols** -- ссылки на уже **объявленные** переменные или строки таблицы. В примерах выше, где я делал цикл по таблице я уже использовал *field-symbol*, куда присваивал адрес "текущей" строки в итерации цикла.

```abap
loop at table assigning <field-symbol>.
" do some shit with <field-symbol>
endloop.
```

Аналогичное действие придется выполнить и сейчас, чтобы полноценно воспользоваться выделенной памятью, как переменной:

```abap
data my_var type ref to data.
" field-symbol можно объявлять с типом any
field-symbols <link_to_data> type any.

create data my_var type ('typename').
assign my_var->* to <link_to_data>.

" do some shit with <link_to_data>
```

## Финишная прямая:

Прикручиваем эти концепты к нашей задаче:

```abap
FIELD-SYMBOLS: <lv_temp>  TYPE ANY.
DATA lo_data TYPE REF TO data.

LOOP AT it_tables ASSIGNING <ls_table>.
  
  CREATE DATA lo_data TYPE (<ls_table>-rollname).
  ASSIGN lo_data->* TO <lv_temp>.

  SELECT SINGLE (<ls_table>-fieldname)
    FROM (<ls_table>-tabname)
    INTO <lv_temp>.

  "sy-subrc аналог return-code в bash
  IF sy-subrc = 0.
    " Обработка успешного селекта
  ELSE.
    " Обработка пустой таблицы
  ENDIF.
ENDLOOP.
```

## Заключение

Внезапно этот костыль компилируется и работает. За очисткой данных можно не следить, т.к. за нас её выполнит сборщик мусора. Нам остаётся красиво нарисовать результаты пользователю. Но это уже совсем другая история.

Вот именно таким образом тривиальные задачи усложняются внутри abap во много раз из-за излишних синтаксических ограничений. 

Например, если бы было возможно выполнить вложенный sql, или исключить блок "into" в запросах, то не пришлось бы в цикле выделять много памяти под абсолютно ненужную переменную, которая никак не обрабатывается в дальнейшем. 

(Кстати, создавая потенциальную утечку памяти, т.к. никто не знает, насколько качественно отрабатывает сборщик мусора)

На этом всё. Всех благ. :)